# Tests generated by Claude Sonnet 4

from datetime import date
from unittest.mock import patch

import pandas as pd
import pytest

from signals.probes.sma_crossover.run import (
    get_is_market_open,
    get_latest_price_and_sma,
    get_raw_ohlcv,
    sma_crossover,
    update_state,
)


class TestUpdateState:
    """Test cases for the update_state function."""

    def test_neutral_to_above_with_tolerance(self):
        """Test transition from neutral to above when price exceeds SMA by tolerance."""
        latest_price = 105.0
        latest_price_sma = 100.0
        upward_tolerance = 3.0  # 3%
        downward_tolerance = 2.0  # 2%
        previous_state = "neutral"

        result = update_state(
            latest_price,
            latest_price_sma,
            upward_tolerance,
            downward_tolerance,
            previous_state,
        )

        assert result == "above"

    def test_neutral_to_below_with_tolerance(self):
        """Test transition from neutral to below when price falls below SMA by tolerance."""
        latest_price = 97.0
        latest_price_sma = 100.0
        upward_tolerance = 3.0  # 3%
        downward_tolerance = 2.0  # 2%
        previous_state = "neutral"

        result = update_state(
            latest_price,
            latest_price_sma,
            upward_tolerance,
            downward_tolerance,
            previous_state,
        )

        assert result == "below"

    def test_neutral_stays_neutral(self):
        """Test that state remains neutral when price is within tolerance."""
        latest_price = 101.0
        latest_price_sma = 100.0
        upward_tolerance = 3.0  # 3%
        downward_tolerance = 2.0  # 2%
        previous_state = "neutral"

        result = update_state(
            latest_price,
            latest_price_sma,
            upward_tolerance,
            downward_tolerance,
            previous_state,
        )

        assert result == "neutral"

    def test_above_stays_above(self):
        """Test that state remains above when price stays above downward tolerance."""
        latest_price = 99.0  # Above 98 (100 * (1 - 2%))
        latest_price_sma = 100.0
        upward_tolerance = 3.0  # 3%
        downward_tolerance = 2.0  # 2%
        previous_state = "above"

        result = update_state(
            latest_price,
            latest_price_sma,
            upward_tolerance,
            downward_tolerance,
            previous_state,
        )

        assert result == "above"

    def test_above_to_below(self):
        """Test transition from above to below when price falls below downward tolerance."""
        latest_price = 97.0  # Below 98 (100 * (1 - 2%))
        latest_price_sma = 100.0
        upward_tolerance = 3.0  # 3%
        downward_tolerance = 2.0  # 2%
        previous_state = "above"

        result = update_state(
            latest_price,
            latest_price_sma,
            upward_tolerance,
            downward_tolerance,
            previous_state,
        )

        assert result == "below"

    def test_below_stays_below(self):
        """Test that state remains below when price stays below upward tolerance."""
        latest_price = 102.0  # Below 103 (100 * (1 + 3%))
        latest_price_sma = 100.0
        upward_tolerance = 3.0  # 3%
        downward_tolerance = 2.0  # 2%
        previous_state = "below"

        result = update_state(
            latest_price,
            latest_price_sma,
            upward_tolerance,
            downward_tolerance,
            previous_state,
        )

        assert result == "below"

    def test_below_to_above(self):
        """Test transition from below to above when price exceeds upward tolerance."""
        latest_price = 104.0  # Above 103 (100 * (1 + 3%))
        latest_price_sma = 100.0
        upward_tolerance = 3.0  # 3%
        downward_tolerance = 2.0  # 2%
        previous_state = "below"

        result = update_state(
            latest_price,
            latest_price_sma,
            upward_tolerance,
            downward_tolerance,
            previous_state,
        )

        assert result == "above"

    def test_none_previous_state_to_above(self):
        """Test transition from None (treated as neutral) to above."""
        latest_price = 104.0
        latest_price_sma = 100.0
        upward_tolerance = 3.0  # 3%
        downward_tolerance = 2.0  # 2%
        previous_state = None

        result = update_state(
            latest_price,
            latest_price_sma,
            upward_tolerance,
            downward_tolerance,
            previous_state,
        )

        assert result == "above"

    def test_zero_tolerance(self):
        """Test behavior with zero tolerance values."""
        latest_price = 100.1
        latest_price_sma = 100.0
        upward_tolerance = 0.0
        downward_tolerance = 0.0
        previous_state = "neutral"

        result = update_state(
            latest_price,
            latest_price_sma,
            upward_tolerance,
            downward_tolerance,
            previous_state,
        )

        assert result == "above"

    def test_invalid_previous_state_raises_error(self):
        """Test that invalid previous_state raises ValueError."""
        latest_price = 100.0
        latest_price_sma = 100.0
        upward_tolerance = 3.0
        downward_tolerance = 2.0
        previous_state = "invalid_state"

        with pytest.raises(ValueError, match="Invalid previous_state: invalid_state"):
            update_state(
                latest_price,
                latest_price_sma,
                upward_tolerance,
                downward_tolerance,
                previous_state,
            )


class TestGetRawOhlcv:
    """Test cases for the get_raw_ohlcv function with mocked yf.download."""

    @patch("signals.probes.sma_crossover.run.yf.download")
    def test_get_raw_ohlcv_success(self, mock_download):
        """Test successful data retrieval from yfinance."""
        # Mock data that yfinance would return
        mock_data = pd.DataFrame(
            {
                ("Close", "AAPL"): [150.0, 151.0, 149.0],
                ("High", "AAPL"): [152.0, 153.0, 151.0],
                ("Low", "AAPL"): [148.0, 149.0, 147.0],
                ("Open", "AAPL"): [149.0, 150.0, 150.5],
                ("Volume", "AAPL"): [1000000, 1100000, 950000],
            }
        )
        mock_data.index = pd.to_datetime(["2024-01-01", "2024-01-02", "2024-01-03"])
        mock_data.index.name = "Date"

        mock_download.return_value = mock_data

        result = get_raw_ohlcv("AAPL", 30, "America/New_York")

        # Verify the function was called with correct parameters
        mock_download.assert_called_once()
        call_args = mock_download.call_args
        assert call_args[1]["interval"] == "1d"
        assert "AAPL" in call_args[0]

        # Verify the result has the expected structure
        assert "Date" in result.columns
        assert "Close" in result.columns
        assert len(result) == 3

    @patch("signals.probes.sma_crossover.run.yf.download")
    def test_get_raw_ohlcv_failure(self, mock_download):
        """Test handling of yfinance download failure."""
        mock_download.return_value = None

        with pytest.raises(
            ValueError, match="Ticker download from Yahoo Finance failed"
        ):
            get_raw_ohlcv("INVALID", 30, "America/New_York")


class TestGetIsMarketOpen:
    """Test cases for the get_is_market_open function."""

    @patch("signals.probes.sma_crossover.run.datetime")
    def test_market_open_normal_hours(self, mock_datetime):
        """Test market open during normal trading hours."""
        # Mock current time to be 10:30 AM
        mock_datetime.now.return_value.strftime.return_value = "10:30"

        result = get_is_market_open("09:00", "16:30", "America/New_York")

        assert result is True

    @patch("signals.probes.sma_crossover.run.datetime")
    def test_market_closed_normal_hours(self, mock_datetime):
        """Test market closed outside normal trading hours."""
        # Mock current time to be 8:00 AM (before market open)
        mock_datetime.now.return_value.strftime.return_value = "08:00"

        result = get_is_market_open("09:00", "16:30", "America/New_York")

        assert result is False

    @patch("signals.probes.sma_crossover.run.datetime")
    def test_market_open_crossing_midnight(self, mock_datetime):
        """Test market open when trading hours cross midnight."""
        # Mock current time to be 22:00 (10:00 PM)
        mock_datetime.now.return_value.strftime.return_value = "22:00"

        result = get_is_market_open("20:00", "16:30", "Asia/Tokyo")

        assert result is True


class TestGetLatestPriceAndSma:
    """Test cases for the get_latest_price_and_sma function."""

    @patch("signals.probes.sma_crossover.run.get_is_market_open")
    def test_get_latest_price_and_sma_market_closed(self, mock_market_open):
        """Test SMA calculation when market is closed."""
        mock_market_open.return_value = False

        # Create test data
        test_data = pd.DataFrame(
            {
                "Date": pd.date_range("2024-01-01", periods=10, freq="D"),
                "Close": [100 + i for i in range(10)],  # Prices from 100 to 109
                "Open": [99 + i for i in range(10)],
                "High": [101 + i for i in range(10)],
                "Low": [98 + i for i in range(10)],
                "Volume": [1000000] * 10,
            }
        )

        latest_close, latest_sma, latest_date = get_latest_price_and_sma(
            test_data, 5, "09:00", "16:30", "America/New_York"
        )

        assert latest_close == 109  # Last close price
        assert latest_sma == 107.0  # SMA of last 5 prices: (105+106+107+108+109)/5
        assert isinstance(latest_date, date)

    @patch("signals.probes.sma_crossover.run.get_is_market_open")
    @patch("signals.probes.sma_crossover.run.datetime")
    def test_get_latest_price_and_sma_market_open(
        self, mock_datetime, mock_market_open
    ):
        """Test SMA calculation when market is open (excludes current day)."""
        mock_market_open.return_value = True
        mock_datetime.now.return_value.date.return_value = date(2024, 1, 10)

        # Create test data including current day
        test_data = pd.DataFrame(
            {
                "Date": pd.date_range("2024-01-01", periods=10, freq="D"),
                "Close": [100 + i for i in range(10)],  # Prices from 100 to 109
                "Open": [99 + i for i in range(10)],
                "High": [101 + i for i in range(10)],
                "Low": [98 + i for i in range(10)],
                "Volume": [1000000] * 10,
            }
        )

        latest_close, latest_sma, latest_date = get_latest_price_and_sma(
            test_data, 5, "09:00", "16:30", "America/New_York"
        )

        # Should exclude current day (2024-01-10), so last price is 108
        assert latest_close == 108
        # SMA of last 5 prices excluding current day: (104+105+106+107+108)/5
        assert latest_sma == 106.0

    def test_insufficient_data_raises_error(self):
        """Test that insufficient data raises ValueError."""
        test_data = pd.DataFrame(
            {
                "Date": pd.date_range("2024-01-01", periods=3, freq="D"),
                "Close": [100, 101, 102],
                "Open": [99, 100, 101],
                "High": [101, 102, 103],
                "Low": [98, 99, 100],
                "Volume": [1000000] * 3,
            }
        )

        with pytest.raises(
            ValueError, match="Not enough data to compute the 5-day SMA"
        ):
            get_latest_price_and_sma(test_data, 5, "09:00", "16:30", "America/New_York")


class TestSmaCrossoverIntegration:
    """Integration tests for the main sma_crossover function."""

    @patch("signals.probes.sma_crossover.run.send_message")
    @patch("signals.probes.sma_crossover.run.os.getenv")
    @patch("signals.probes.sma_crossover.run.get_raw_ohlcv")
    def test_sma_crossover_state_change(
        self, mock_get_raw, mock_getenv, mock_send_message
    ):
        """Test complete sma_crossover function with state change."""
        # Mock environment variables
        mock_getenv.side_effect = lambda key: {
            "TELEGRAM_CHAT_ID": "test_chat_id",
            "TELEGRAM_BOT_TOKEN": "test_token",
        }.get(key)

        # Mock OHLCV data
        test_data = pd.DataFrame(
            {
                "Date": pd.date_range("2024-01-01", periods=10, freq="D"),
                "Close": [
                    100,
                    101,
                    102,
                    103,
                    104,
                    105,
                    106,
                    107,
                    108,
                    110,
                ],  # Rising trend
                "Open": [99, 100, 101, 102, 103, 104, 105, 106, 107, 109],
                "High": [101, 102, 103, 104, 105, 106, 107, 108, 109, 111],
                "Low": [98, 99, 100, 101, 102, 103, 104, 105, 106, 108],
                "Volume": [1000000] * 10,
            }
        )
        mock_get_raw.return_value = test_data

        # Capture the printed state
        with patch("builtins.print") as mock_print:
            sma_crossover(
                ticker="AAPL",
                lookback=5,
                trading_hours_open="09:00",
                trading_hours_close="16:30",
                timezone="America/New_York",
                upward_tolerance=2.0,
                downward_tolerance=2.0,
                previous_state="neutral",
            )

        # Verify send_message was called
        mock_send_message.assert_called_once()

        # Verify the state was printed
        mock_print.assert_called_once()
